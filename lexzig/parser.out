Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    BANG
    BAR
    BUILTIN_FUNCTION
    CHAR
    DIV_EQUAL
    DOT
    ELLIPSIS
    ELSE
    ENUM
    EXPORT
    EXTERN
    FAT_ARROW
    FOR
    GREATER_THAN
    IF
    IS_EQUAL_TO
    IS_NOT
    IS_NOT_EQUAL
    LBRACE
    LT
    MINUS_EQUAL
    MODULE
    MOD_EQUAL
    MULT_EQUAL
    PLUS_EQUAL
    RBRACE
    RETURN
    STRING
    STRUCT
    SWITCH
    TEST
    THREADLOCAL
    TRY
    UNDERSCORE
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt stmts
Rule 2     stmts -> stmt stmts
Rule 3     stmts -> empty
Rule 4     stmt -> assignment_stmt
Rule 5     stmt -> functiondecl_stmt
Rule 6     assignment_stmt -> vardecl IDENT assignment_stmt_tail
Rule 7     assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail
Rule 8     assignment_stmt_tail -> EQUAL expression SEMICOLON
Rule 9     functiondecl_stmt -> function_signature function_body
Rule 10    param -> IDENT colon_type
Rule 11    params_list -> param
Rule 12    params_list -> param COMMA params_list
Rule 13    params_list -> empty
Rule 14    function_signature -> access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl
Rule 15    function_body -> LCURLY stmts RCURLY
Rule 16    colon_type -> COLON typedecl
Rule 17    colon_type -> empty
Rule 18    access_modifier -> PUB
Rule 19    access_modifier -> empty
Rule 20    vardecl -> VAR
Rule 21    vardecl -> CONST
Rule 22    vardecl -> COMPTIME
Rule 23    typedecl -> TYPE_I32
Rule 24    typedecl -> TYPE_I8
Rule 25    typedecl -> TYPE_U8
Rule 26    typedecl -> TYPE_I16
Rule 27    typedecl -> TYPE_U16
Rule 28    typedecl -> TYPE_U32
Rule 29    typedecl -> TYPE_I64
Rule 30    typedecl -> TYPE_U64
Rule 31    typedecl -> TYPE_I128
Rule 32    typedecl -> TYPE_U128
Rule 33    typedecl -> TYPE_ISIZE
Rule 34    typedecl -> TYPE_USIZE
Rule 35    typedecl -> TYPE_C_SHORT
Rule 36    typedecl -> TYPE_C_USHORT
Rule 37    typedecl -> TYPE_C_INT
Rule 38    typedecl -> TYPE_C_UINT
Rule 39    typedecl -> TYPE_C_LONG
Rule 40    typedecl -> TYPE_C_ULONG
Rule 41    typedecl -> TYPE_C_LONGLONG
Rule 42    typedecl -> TYPE_C_ULONGLONG
Rule 43    typedecl -> TYPE_C_LONGDOUBLE
Rule 44    typedecl -> TYPE_F16
Rule 45    typedecl -> TYPE_F32
Rule 46    typedecl -> TYPE_F64
Rule 47    typedecl -> TYPE_F80
Rule 48    typedecl -> TYPE_F128
Rule 49    typedecl -> TYPE_BOOL
Rule 50    typedecl -> TYPE_ANYOPAQUE
Rule 51    typedecl -> TYPE_VOID
Rule 52    typedecl -> TYPE_NORETURN
Rule 53    typedecl -> TYPE_TYPE
Rule 54    typedecl -> TYPE_ANYERROR
Rule 55    typedecl -> TYPE_ANYTYPE
Rule 56    typedecl -> TYPE_COMPTIME_INT
Rule 57    typedecl -> TYPE_COMPTIME_FLOAT
Rule 58    typedecl -> TYPE_NULL
Rule 59    typedecl -> TYPE_UNDEFINED
Rule 60    expression -> INTEGER PLUS INTEGER
Rule 61    expression -> INTEGER MINUS INTEGER
Rule 62    expression -> INTEGER MULTIPLICATION INTEGER
Rule 63    expression -> INTEGER DIVISION INTEGER
Rule 64    expression -> INTEGER
Rule 65    empty -> <empty>

Terminals, with rules where they appear

AMPERSAND            : 
BANG                 : 
BAR                  : 
BUILTIN_FUNCTION     : 
CHAR                 : 
COLON                : 7 16
COMMA                : 12
COMPTIME             : 22
CONST                : 21
DIVISION             : 63
DIV_EQUAL            : 
DOT                  : 
ELLIPSIS             : 
ELSE                 : 
ENUM                 : 
EQUAL                : 8
EXPORT               : 
EXTERN               : 
FAT_ARROW            : 
FOR                  : 
FUNCTION             : 14
GREATER_THAN         : 
IDENT                : 6 7 10 14
IF                   : 
INTEGER              : 60 60 61 61 62 62 63 63 64
IS_EQUAL_TO          : 
IS_NOT               : 
IS_NOT_EQUAL         : 
LBRACE               : 
LCURLY               : 15
LPAREN               : 14
LT                   : 
MINUS                : 61
MINUS_EQUAL          : 
MODULE               : 
MOD_EQUAL            : 
MULTIPLICATION       : 62
MULT_EQUAL           : 
PLUS                 : 60
PLUS_EQUAL           : 
PUB                  : 18
RBRACE               : 
RCURLY               : 15
RETURN               : 
RPAREN               : 14
SEMICOLON            : 8
STRING               : 
STRUCT               : 
SWITCH               : 
TEST                 : 
THREADLOCAL          : 
TRY                  : 
TYPE_ANYERROR        : 54
TYPE_ANYOPAQUE       : 50
TYPE_ANYTYPE         : 55
TYPE_BOOL            : 49
TYPE_COMPTIME_FLOAT  : 57
TYPE_COMPTIME_INT    : 56
TYPE_C_INT           : 37
TYPE_C_LONG          : 39
TYPE_C_LONGDOUBLE    : 43
TYPE_C_LONGLONG      : 41
TYPE_C_SHORT         : 35
TYPE_C_UINT          : 38
TYPE_C_ULONG         : 40
TYPE_C_ULONGLONG     : 42
TYPE_C_USHORT        : 36
TYPE_F128            : 48
TYPE_F16             : 44
TYPE_F32             : 45
TYPE_F64             : 46
TYPE_F80             : 47
TYPE_I128            : 31
TYPE_I16             : 26
TYPE_I32             : 23
TYPE_I64             : 29
TYPE_I8              : 24
TYPE_ISIZE           : 33
TYPE_NORETURN        : 52
TYPE_NULL            : 58
TYPE_TYPE            : 53
TYPE_U128            : 32
TYPE_U16             : 27
TYPE_U32             : 28
TYPE_U64             : 30
TYPE_U8              : 25
TYPE_UNDEFINED       : 59
TYPE_USIZE           : 34
TYPE_VOID            : 51
UNDERSCORE           : 
VAR                  : 20
WHILE                : 
error                : 

Nonterminals, with rules where they appear

access_modifier      : 14
assignment_stmt      : 4
assignment_stmt_tail : 6 7
colon_type           : 10
empty                : 3 13 17 19
expression           : 8
function_body        : 9
function_signature   : 9
functiondecl_stmt    : 5
param                : 11 12
params_list          : 12 14
program              : 0
stmt                 : 1 2
stmts                : 1 2 15
typedecl             : 7 14 16
vardecl              : 6 7

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt stmts
    (4) stmt -> . assignment_stmt
    (5) stmt -> . functiondecl_stmt
    (6) assignment_stmt -> . vardecl IDENT assignment_stmt_tail
    (7) assignment_stmt -> . vardecl IDENT COLON typedecl assignment_stmt_tail
    (9) functiondecl_stmt -> . function_signature function_body
    (20) vardecl -> . VAR
    (21) vardecl -> . CONST
    (22) vardecl -> . COMPTIME
    (14) function_signature -> . access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl
    (18) access_modifier -> . PUB
    (19) access_modifier -> . empty
    (65) empty -> .

    VAR             shift and go to state 7
    CONST           shift and go to state 8
    COMPTIME        shift and go to state 9
    PUB             shift and go to state 11
    FUNCTION        reduce using rule 65 (empty -> .)

    program                        shift and go to state 1
    stmt                           shift and go to state 2
    assignment_stmt                shift and go to state 3
    functiondecl_stmt              shift and go to state 4
    vardecl                        shift and go to state 5
    function_signature             shift and go to state 6
    access_modifier                shift and go to state 10
    empty                          shift and go to state 12

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt . stmts
    (2) stmts -> . stmt stmts
    (3) stmts -> . empty
    (4) stmt -> . assignment_stmt
    (5) stmt -> . functiondecl_stmt
    (65) empty -> .
    (6) assignment_stmt -> . vardecl IDENT assignment_stmt_tail
    (7) assignment_stmt -> . vardecl IDENT COLON typedecl assignment_stmt_tail
    (9) functiondecl_stmt -> . function_signature function_body
    (20) vardecl -> . VAR
    (21) vardecl -> . CONST
    (22) vardecl -> . COMPTIME
    (14) function_signature -> . access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl
    (18) access_modifier -> . PUB
    (19) access_modifier -> . empty

    $end            reduce using rule 65 (empty -> .)
    FUNCTION        reduce using rule 65 (empty -> .)
    VAR             shift and go to state 7
    CONST           shift and go to state 8
    COMPTIME        shift and go to state 9
    PUB             shift and go to state 11

    stmt                           shift and go to state 13
    stmts                          shift and go to state 14
    empty                          shift and go to state 15
    assignment_stmt                shift and go to state 3
    functiondecl_stmt              shift and go to state 4
    vardecl                        shift and go to state 5
    function_signature             shift and go to state 6
    access_modifier                shift and go to state 10

state 3

    (4) stmt -> assignment_stmt .

    VAR             reduce using rule 4 (stmt -> assignment_stmt .)
    CONST           reduce using rule 4 (stmt -> assignment_stmt .)
    COMPTIME        reduce using rule 4 (stmt -> assignment_stmt .)
    PUB             reduce using rule 4 (stmt -> assignment_stmt .)
    FUNCTION        reduce using rule 4 (stmt -> assignment_stmt .)
    $end            reduce using rule 4 (stmt -> assignment_stmt .)
    RCURLY          reduce using rule 4 (stmt -> assignment_stmt .)


state 4

    (5) stmt -> functiondecl_stmt .

    VAR             reduce using rule 5 (stmt -> functiondecl_stmt .)
    CONST           reduce using rule 5 (stmt -> functiondecl_stmt .)
    COMPTIME        reduce using rule 5 (stmt -> functiondecl_stmt .)
    PUB             reduce using rule 5 (stmt -> functiondecl_stmt .)
    FUNCTION        reduce using rule 5 (stmt -> functiondecl_stmt .)
    $end            reduce using rule 5 (stmt -> functiondecl_stmt .)
    RCURLY          reduce using rule 5 (stmt -> functiondecl_stmt .)


state 5

    (6) assignment_stmt -> vardecl . IDENT assignment_stmt_tail
    (7) assignment_stmt -> vardecl . IDENT COLON typedecl assignment_stmt_tail

    IDENT           shift and go to state 16


state 6

    (9) functiondecl_stmt -> function_signature . function_body
    (15) function_body -> . LCURLY stmts RCURLY

    LCURLY          shift and go to state 18

    function_body                  shift and go to state 17

state 7

    (20) vardecl -> VAR .

    IDENT           reduce using rule 20 (vardecl -> VAR .)


state 8

    (21) vardecl -> CONST .

    IDENT           reduce using rule 21 (vardecl -> CONST .)


state 9

    (22) vardecl -> COMPTIME .

    IDENT           reduce using rule 22 (vardecl -> COMPTIME .)


state 10

    (14) function_signature -> access_modifier . FUNCTION IDENT LPAREN params_list RPAREN typedecl

    FUNCTION        shift and go to state 19


state 11

    (18) access_modifier -> PUB .

    FUNCTION        reduce using rule 18 (access_modifier -> PUB .)


state 12

    (19) access_modifier -> empty .

    FUNCTION        reduce using rule 19 (access_modifier -> empty .)


state 13

    (2) stmts -> stmt . stmts
    (2) stmts -> . stmt stmts
    (3) stmts -> . empty
    (4) stmt -> . assignment_stmt
    (5) stmt -> . functiondecl_stmt
    (65) empty -> .
    (6) assignment_stmt -> . vardecl IDENT assignment_stmt_tail
    (7) assignment_stmt -> . vardecl IDENT COLON typedecl assignment_stmt_tail
    (9) functiondecl_stmt -> . function_signature function_body
    (20) vardecl -> . VAR
    (21) vardecl -> . CONST
    (22) vardecl -> . COMPTIME
    (14) function_signature -> . access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl
    (18) access_modifier -> . PUB
    (19) access_modifier -> . empty

    $end            reduce using rule 65 (empty -> .)
    RCURLY          reduce using rule 65 (empty -> .)
    FUNCTION        reduce using rule 65 (empty -> .)
    VAR             shift and go to state 7
    CONST           shift and go to state 8
    COMPTIME        shift and go to state 9
    PUB             shift and go to state 11

    stmt                           shift and go to state 13
    stmts                          shift and go to state 20
    empty                          shift and go to state 15
    assignment_stmt                shift and go to state 3
    functiondecl_stmt              shift and go to state 4
    vardecl                        shift and go to state 5
    function_signature             shift and go to state 6
    access_modifier                shift and go to state 10

state 14

    (1) program -> stmt stmts .

    $end            reduce using rule 1 (program -> stmt stmts .)


state 15

    (3) stmts -> empty .
    (19) access_modifier -> empty .

    $end            reduce using rule 3 (stmts -> empty .)
    RCURLY          reduce using rule 3 (stmts -> empty .)
    FUNCTION        reduce using rule 19 (access_modifier -> empty .)


state 16

    (6) assignment_stmt -> vardecl IDENT . assignment_stmt_tail
    (7) assignment_stmt -> vardecl IDENT . COLON typedecl assignment_stmt_tail
    (8) assignment_stmt_tail -> . EQUAL expression SEMICOLON

    COLON           shift and go to state 22
    EQUAL           shift and go to state 23

    assignment_stmt_tail           shift and go to state 21

state 17

    (9) functiondecl_stmt -> function_signature function_body .

    VAR             reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)
    CONST           reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)
    COMPTIME        reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)
    PUB             reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)
    FUNCTION        reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)
    $end            reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)
    RCURLY          reduce using rule 9 (functiondecl_stmt -> function_signature function_body .)


state 18

    (15) function_body -> LCURLY . stmts RCURLY
    (2) stmts -> . stmt stmts
    (3) stmts -> . empty
    (4) stmt -> . assignment_stmt
    (5) stmt -> . functiondecl_stmt
    (65) empty -> .
    (6) assignment_stmt -> . vardecl IDENT assignment_stmt_tail
    (7) assignment_stmt -> . vardecl IDENT COLON typedecl assignment_stmt_tail
    (9) functiondecl_stmt -> . function_signature function_body
    (20) vardecl -> . VAR
    (21) vardecl -> . CONST
    (22) vardecl -> . COMPTIME
    (14) function_signature -> . access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl
    (18) access_modifier -> . PUB
    (19) access_modifier -> . empty

    RCURLY          reduce using rule 65 (empty -> .)
    FUNCTION        reduce using rule 65 (empty -> .)
    VAR             shift and go to state 7
    CONST           shift and go to state 8
    COMPTIME        shift and go to state 9
    PUB             shift and go to state 11

    stmts                          shift and go to state 24
    stmt                           shift and go to state 13
    empty                          shift and go to state 15
    assignment_stmt                shift and go to state 3
    functiondecl_stmt              shift and go to state 4
    vardecl                        shift and go to state 5
    function_signature             shift and go to state 6
    access_modifier                shift and go to state 10

state 19

    (14) function_signature -> access_modifier FUNCTION . IDENT LPAREN params_list RPAREN typedecl

    IDENT           shift and go to state 25


state 20

    (2) stmts -> stmt stmts .

    $end            reduce using rule 2 (stmts -> stmt stmts .)
    RCURLY          reduce using rule 2 (stmts -> stmt stmts .)


state 21

    (6) assignment_stmt -> vardecl IDENT assignment_stmt_tail .

    VAR             reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)
    CONST           reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)
    COMPTIME        reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)
    PUB             reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)
    FUNCTION        reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)
    $end            reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)
    RCURLY          reduce using rule 6 (assignment_stmt -> vardecl IDENT assignment_stmt_tail .)


state 22

    (7) assignment_stmt -> vardecl IDENT COLON . typedecl assignment_stmt_tail
    (23) typedecl -> . TYPE_I32
    (24) typedecl -> . TYPE_I8
    (25) typedecl -> . TYPE_U8
    (26) typedecl -> . TYPE_I16
    (27) typedecl -> . TYPE_U16
    (28) typedecl -> . TYPE_U32
    (29) typedecl -> . TYPE_I64
    (30) typedecl -> . TYPE_U64
    (31) typedecl -> . TYPE_I128
    (32) typedecl -> . TYPE_U128
    (33) typedecl -> . TYPE_ISIZE
    (34) typedecl -> . TYPE_USIZE
    (35) typedecl -> . TYPE_C_SHORT
    (36) typedecl -> . TYPE_C_USHORT
    (37) typedecl -> . TYPE_C_INT
    (38) typedecl -> . TYPE_C_UINT
    (39) typedecl -> . TYPE_C_LONG
    (40) typedecl -> . TYPE_C_ULONG
    (41) typedecl -> . TYPE_C_LONGLONG
    (42) typedecl -> . TYPE_C_ULONGLONG
    (43) typedecl -> . TYPE_C_LONGDOUBLE
    (44) typedecl -> . TYPE_F16
    (45) typedecl -> . TYPE_F32
    (46) typedecl -> . TYPE_F64
    (47) typedecl -> . TYPE_F80
    (48) typedecl -> . TYPE_F128
    (49) typedecl -> . TYPE_BOOL
    (50) typedecl -> . TYPE_ANYOPAQUE
    (51) typedecl -> . TYPE_VOID
    (52) typedecl -> . TYPE_NORETURN
    (53) typedecl -> . TYPE_TYPE
    (54) typedecl -> . TYPE_ANYERROR
    (55) typedecl -> . TYPE_ANYTYPE
    (56) typedecl -> . TYPE_COMPTIME_INT
    (57) typedecl -> . TYPE_COMPTIME_FLOAT
    (58) typedecl -> . TYPE_NULL
    (59) typedecl -> . TYPE_UNDEFINED

    TYPE_I32        shift and go to state 27
    TYPE_I8         shift and go to state 28
    TYPE_U8         shift and go to state 29
    TYPE_I16        shift and go to state 30
    TYPE_U16        shift and go to state 31
    TYPE_U32        shift and go to state 32
    TYPE_I64        shift and go to state 33
    TYPE_U64        shift and go to state 34
    TYPE_I128       shift and go to state 35
    TYPE_U128       shift and go to state 36
    TYPE_ISIZE      shift and go to state 37
    TYPE_USIZE      shift and go to state 38
    TYPE_C_SHORT    shift and go to state 39
    TYPE_C_USHORT   shift and go to state 40
    TYPE_C_INT      shift and go to state 41
    TYPE_C_UINT     shift and go to state 42
    TYPE_C_LONG     shift and go to state 43
    TYPE_C_ULONG    shift and go to state 44
    TYPE_C_LONGLONG shift and go to state 45
    TYPE_C_ULONGLONG shift and go to state 46
    TYPE_C_LONGDOUBLE shift and go to state 47
    TYPE_F16        shift and go to state 48
    TYPE_F32        shift and go to state 49
    TYPE_F64        shift and go to state 50
    TYPE_F80        shift and go to state 51
    TYPE_F128       shift and go to state 52
    TYPE_BOOL       shift and go to state 53
    TYPE_ANYOPAQUE  shift and go to state 54
    TYPE_VOID       shift and go to state 55
    TYPE_NORETURN   shift and go to state 56
    TYPE_TYPE       shift and go to state 57
    TYPE_ANYERROR   shift and go to state 58
    TYPE_ANYTYPE    shift and go to state 59
    TYPE_COMPTIME_INT shift and go to state 60
    TYPE_COMPTIME_FLOAT shift and go to state 61
    TYPE_NULL       shift and go to state 62
    TYPE_UNDEFINED  shift and go to state 63

    typedecl                       shift and go to state 26

state 23

    (8) assignment_stmt_tail -> EQUAL . expression SEMICOLON
    (60) expression -> . INTEGER PLUS INTEGER
    (61) expression -> . INTEGER MINUS INTEGER
    (62) expression -> . INTEGER MULTIPLICATION INTEGER
    (63) expression -> . INTEGER DIVISION INTEGER
    (64) expression -> . INTEGER

    INTEGER         shift and go to state 65

    expression                     shift and go to state 64

state 24

    (15) function_body -> LCURLY stmts . RCURLY

    RCURLY          shift and go to state 66


state 25

    (14) function_signature -> access_modifier FUNCTION IDENT . LPAREN params_list RPAREN typedecl

    LPAREN          shift and go to state 67


state 26

    (7) assignment_stmt -> vardecl IDENT COLON typedecl . assignment_stmt_tail
    (8) assignment_stmt_tail -> . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 23

    assignment_stmt_tail           shift and go to state 68

state 27

    (23) typedecl -> TYPE_I32 .

    EQUAL           reduce using rule 23 (typedecl -> TYPE_I32 .)
    COMMA           reduce using rule 23 (typedecl -> TYPE_I32 .)
    RPAREN          reduce using rule 23 (typedecl -> TYPE_I32 .)
    LCURLY          reduce using rule 23 (typedecl -> TYPE_I32 .)


state 28

    (24) typedecl -> TYPE_I8 .

    EQUAL           reduce using rule 24 (typedecl -> TYPE_I8 .)
    COMMA           reduce using rule 24 (typedecl -> TYPE_I8 .)
    RPAREN          reduce using rule 24 (typedecl -> TYPE_I8 .)
    LCURLY          reduce using rule 24 (typedecl -> TYPE_I8 .)


state 29

    (25) typedecl -> TYPE_U8 .

    EQUAL           reduce using rule 25 (typedecl -> TYPE_U8 .)
    COMMA           reduce using rule 25 (typedecl -> TYPE_U8 .)
    RPAREN          reduce using rule 25 (typedecl -> TYPE_U8 .)
    LCURLY          reduce using rule 25 (typedecl -> TYPE_U8 .)


state 30

    (26) typedecl -> TYPE_I16 .

    EQUAL           reduce using rule 26 (typedecl -> TYPE_I16 .)
    COMMA           reduce using rule 26 (typedecl -> TYPE_I16 .)
    RPAREN          reduce using rule 26 (typedecl -> TYPE_I16 .)
    LCURLY          reduce using rule 26 (typedecl -> TYPE_I16 .)


state 31

    (27) typedecl -> TYPE_U16 .

    EQUAL           reduce using rule 27 (typedecl -> TYPE_U16 .)
    COMMA           reduce using rule 27 (typedecl -> TYPE_U16 .)
    RPAREN          reduce using rule 27 (typedecl -> TYPE_U16 .)
    LCURLY          reduce using rule 27 (typedecl -> TYPE_U16 .)


state 32

    (28) typedecl -> TYPE_U32 .

    EQUAL           reduce using rule 28 (typedecl -> TYPE_U32 .)
    COMMA           reduce using rule 28 (typedecl -> TYPE_U32 .)
    RPAREN          reduce using rule 28 (typedecl -> TYPE_U32 .)
    LCURLY          reduce using rule 28 (typedecl -> TYPE_U32 .)


state 33

    (29) typedecl -> TYPE_I64 .

    EQUAL           reduce using rule 29 (typedecl -> TYPE_I64 .)
    COMMA           reduce using rule 29 (typedecl -> TYPE_I64 .)
    RPAREN          reduce using rule 29 (typedecl -> TYPE_I64 .)
    LCURLY          reduce using rule 29 (typedecl -> TYPE_I64 .)


state 34

    (30) typedecl -> TYPE_U64 .

    EQUAL           reduce using rule 30 (typedecl -> TYPE_U64 .)
    COMMA           reduce using rule 30 (typedecl -> TYPE_U64 .)
    RPAREN          reduce using rule 30 (typedecl -> TYPE_U64 .)
    LCURLY          reduce using rule 30 (typedecl -> TYPE_U64 .)


state 35

    (31) typedecl -> TYPE_I128 .

    EQUAL           reduce using rule 31 (typedecl -> TYPE_I128 .)
    COMMA           reduce using rule 31 (typedecl -> TYPE_I128 .)
    RPAREN          reduce using rule 31 (typedecl -> TYPE_I128 .)
    LCURLY          reduce using rule 31 (typedecl -> TYPE_I128 .)


state 36

    (32) typedecl -> TYPE_U128 .

    EQUAL           reduce using rule 32 (typedecl -> TYPE_U128 .)
    COMMA           reduce using rule 32 (typedecl -> TYPE_U128 .)
    RPAREN          reduce using rule 32 (typedecl -> TYPE_U128 .)
    LCURLY          reduce using rule 32 (typedecl -> TYPE_U128 .)


state 37

    (33) typedecl -> TYPE_ISIZE .

    EQUAL           reduce using rule 33 (typedecl -> TYPE_ISIZE .)
    COMMA           reduce using rule 33 (typedecl -> TYPE_ISIZE .)
    RPAREN          reduce using rule 33 (typedecl -> TYPE_ISIZE .)
    LCURLY          reduce using rule 33 (typedecl -> TYPE_ISIZE .)


state 38

    (34) typedecl -> TYPE_USIZE .

    EQUAL           reduce using rule 34 (typedecl -> TYPE_USIZE .)
    COMMA           reduce using rule 34 (typedecl -> TYPE_USIZE .)
    RPAREN          reduce using rule 34 (typedecl -> TYPE_USIZE .)
    LCURLY          reduce using rule 34 (typedecl -> TYPE_USIZE .)


state 39

    (35) typedecl -> TYPE_C_SHORT .

    EQUAL           reduce using rule 35 (typedecl -> TYPE_C_SHORT .)
    COMMA           reduce using rule 35 (typedecl -> TYPE_C_SHORT .)
    RPAREN          reduce using rule 35 (typedecl -> TYPE_C_SHORT .)
    LCURLY          reduce using rule 35 (typedecl -> TYPE_C_SHORT .)


state 40

    (36) typedecl -> TYPE_C_USHORT .

    EQUAL           reduce using rule 36 (typedecl -> TYPE_C_USHORT .)
    COMMA           reduce using rule 36 (typedecl -> TYPE_C_USHORT .)
    RPAREN          reduce using rule 36 (typedecl -> TYPE_C_USHORT .)
    LCURLY          reduce using rule 36 (typedecl -> TYPE_C_USHORT .)


state 41

    (37) typedecl -> TYPE_C_INT .

    EQUAL           reduce using rule 37 (typedecl -> TYPE_C_INT .)
    COMMA           reduce using rule 37 (typedecl -> TYPE_C_INT .)
    RPAREN          reduce using rule 37 (typedecl -> TYPE_C_INT .)
    LCURLY          reduce using rule 37 (typedecl -> TYPE_C_INT .)


state 42

    (38) typedecl -> TYPE_C_UINT .

    EQUAL           reduce using rule 38 (typedecl -> TYPE_C_UINT .)
    COMMA           reduce using rule 38 (typedecl -> TYPE_C_UINT .)
    RPAREN          reduce using rule 38 (typedecl -> TYPE_C_UINT .)
    LCURLY          reduce using rule 38 (typedecl -> TYPE_C_UINT .)


state 43

    (39) typedecl -> TYPE_C_LONG .

    EQUAL           reduce using rule 39 (typedecl -> TYPE_C_LONG .)
    COMMA           reduce using rule 39 (typedecl -> TYPE_C_LONG .)
    RPAREN          reduce using rule 39 (typedecl -> TYPE_C_LONG .)
    LCURLY          reduce using rule 39 (typedecl -> TYPE_C_LONG .)


state 44

    (40) typedecl -> TYPE_C_ULONG .

    EQUAL           reduce using rule 40 (typedecl -> TYPE_C_ULONG .)
    COMMA           reduce using rule 40 (typedecl -> TYPE_C_ULONG .)
    RPAREN          reduce using rule 40 (typedecl -> TYPE_C_ULONG .)
    LCURLY          reduce using rule 40 (typedecl -> TYPE_C_ULONG .)


state 45

    (41) typedecl -> TYPE_C_LONGLONG .

    EQUAL           reduce using rule 41 (typedecl -> TYPE_C_LONGLONG .)
    COMMA           reduce using rule 41 (typedecl -> TYPE_C_LONGLONG .)
    RPAREN          reduce using rule 41 (typedecl -> TYPE_C_LONGLONG .)
    LCURLY          reduce using rule 41 (typedecl -> TYPE_C_LONGLONG .)


state 46

    (42) typedecl -> TYPE_C_ULONGLONG .

    EQUAL           reduce using rule 42 (typedecl -> TYPE_C_ULONGLONG .)
    COMMA           reduce using rule 42 (typedecl -> TYPE_C_ULONGLONG .)
    RPAREN          reduce using rule 42 (typedecl -> TYPE_C_ULONGLONG .)
    LCURLY          reduce using rule 42 (typedecl -> TYPE_C_ULONGLONG .)


state 47

    (43) typedecl -> TYPE_C_LONGDOUBLE .

    EQUAL           reduce using rule 43 (typedecl -> TYPE_C_LONGDOUBLE .)
    COMMA           reduce using rule 43 (typedecl -> TYPE_C_LONGDOUBLE .)
    RPAREN          reduce using rule 43 (typedecl -> TYPE_C_LONGDOUBLE .)
    LCURLY          reduce using rule 43 (typedecl -> TYPE_C_LONGDOUBLE .)


state 48

    (44) typedecl -> TYPE_F16 .

    EQUAL           reduce using rule 44 (typedecl -> TYPE_F16 .)
    COMMA           reduce using rule 44 (typedecl -> TYPE_F16 .)
    RPAREN          reduce using rule 44 (typedecl -> TYPE_F16 .)
    LCURLY          reduce using rule 44 (typedecl -> TYPE_F16 .)


state 49

    (45) typedecl -> TYPE_F32 .

    EQUAL           reduce using rule 45 (typedecl -> TYPE_F32 .)
    COMMA           reduce using rule 45 (typedecl -> TYPE_F32 .)
    RPAREN          reduce using rule 45 (typedecl -> TYPE_F32 .)
    LCURLY          reduce using rule 45 (typedecl -> TYPE_F32 .)


state 50

    (46) typedecl -> TYPE_F64 .

    EQUAL           reduce using rule 46 (typedecl -> TYPE_F64 .)
    COMMA           reduce using rule 46 (typedecl -> TYPE_F64 .)
    RPAREN          reduce using rule 46 (typedecl -> TYPE_F64 .)
    LCURLY          reduce using rule 46 (typedecl -> TYPE_F64 .)


state 51

    (47) typedecl -> TYPE_F80 .

    EQUAL           reduce using rule 47 (typedecl -> TYPE_F80 .)
    COMMA           reduce using rule 47 (typedecl -> TYPE_F80 .)
    RPAREN          reduce using rule 47 (typedecl -> TYPE_F80 .)
    LCURLY          reduce using rule 47 (typedecl -> TYPE_F80 .)


state 52

    (48) typedecl -> TYPE_F128 .

    EQUAL           reduce using rule 48 (typedecl -> TYPE_F128 .)
    COMMA           reduce using rule 48 (typedecl -> TYPE_F128 .)
    RPAREN          reduce using rule 48 (typedecl -> TYPE_F128 .)
    LCURLY          reduce using rule 48 (typedecl -> TYPE_F128 .)


state 53

    (49) typedecl -> TYPE_BOOL .

    EQUAL           reduce using rule 49 (typedecl -> TYPE_BOOL .)
    COMMA           reduce using rule 49 (typedecl -> TYPE_BOOL .)
    RPAREN          reduce using rule 49 (typedecl -> TYPE_BOOL .)
    LCURLY          reduce using rule 49 (typedecl -> TYPE_BOOL .)


state 54

    (50) typedecl -> TYPE_ANYOPAQUE .

    EQUAL           reduce using rule 50 (typedecl -> TYPE_ANYOPAQUE .)
    COMMA           reduce using rule 50 (typedecl -> TYPE_ANYOPAQUE .)
    RPAREN          reduce using rule 50 (typedecl -> TYPE_ANYOPAQUE .)
    LCURLY          reduce using rule 50 (typedecl -> TYPE_ANYOPAQUE .)


state 55

    (51) typedecl -> TYPE_VOID .

    EQUAL           reduce using rule 51 (typedecl -> TYPE_VOID .)
    COMMA           reduce using rule 51 (typedecl -> TYPE_VOID .)
    RPAREN          reduce using rule 51 (typedecl -> TYPE_VOID .)
    LCURLY          reduce using rule 51 (typedecl -> TYPE_VOID .)


state 56

    (52) typedecl -> TYPE_NORETURN .

    EQUAL           reduce using rule 52 (typedecl -> TYPE_NORETURN .)
    COMMA           reduce using rule 52 (typedecl -> TYPE_NORETURN .)
    RPAREN          reduce using rule 52 (typedecl -> TYPE_NORETURN .)
    LCURLY          reduce using rule 52 (typedecl -> TYPE_NORETURN .)


state 57

    (53) typedecl -> TYPE_TYPE .

    EQUAL           reduce using rule 53 (typedecl -> TYPE_TYPE .)
    COMMA           reduce using rule 53 (typedecl -> TYPE_TYPE .)
    RPAREN          reduce using rule 53 (typedecl -> TYPE_TYPE .)
    LCURLY          reduce using rule 53 (typedecl -> TYPE_TYPE .)


state 58

    (54) typedecl -> TYPE_ANYERROR .

    EQUAL           reduce using rule 54 (typedecl -> TYPE_ANYERROR .)
    COMMA           reduce using rule 54 (typedecl -> TYPE_ANYERROR .)
    RPAREN          reduce using rule 54 (typedecl -> TYPE_ANYERROR .)
    LCURLY          reduce using rule 54 (typedecl -> TYPE_ANYERROR .)


state 59

    (55) typedecl -> TYPE_ANYTYPE .

    EQUAL           reduce using rule 55 (typedecl -> TYPE_ANYTYPE .)
    COMMA           reduce using rule 55 (typedecl -> TYPE_ANYTYPE .)
    RPAREN          reduce using rule 55 (typedecl -> TYPE_ANYTYPE .)
    LCURLY          reduce using rule 55 (typedecl -> TYPE_ANYTYPE .)


state 60

    (56) typedecl -> TYPE_COMPTIME_INT .

    EQUAL           reduce using rule 56 (typedecl -> TYPE_COMPTIME_INT .)
    COMMA           reduce using rule 56 (typedecl -> TYPE_COMPTIME_INT .)
    RPAREN          reduce using rule 56 (typedecl -> TYPE_COMPTIME_INT .)
    LCURLY          reduce using rule 56 (typedecl -> TYPE_COMPTIME_INT .)


state 61

    (57) typedecl -> TYPE_COMPTIME_FLOAT .

    EQUAL           reduce using rule 57 (typedecl -> TYPE_COMPTIME_FLOAT .)
    COMMA           reduce using rule 57 (typedecl -> TYPE_COMPTIME_FLOAT .)
    RPAREN          reduce using rule 57 (typedecl -> TYPE_COMPTIME_FLOAT .)
    LCURLY          reduce using rule 57 (typedecl -> TYPE_COMPTIME_FLOAT .)


state 62

    (58) typedecl -> TYPE_NULL .

    EQUAL           reduce using rule 58 (typedecl -> TYPE_NULL .)
    COMMA           reduce using rule 58 (typedecl -> TYPE_NULL .)
    RPAREN          reduce using rule 58 (typedecl -> TYPE_NULL .)
    LCURLY          reduce using rule 58 (typedecl -> TYPE_NULL .)


state 63

    (59) typedecl -> TYPE_UNDEFINED .

    EQUAL           reduce using rule 59 (typedecl -> TYPE_UNDEFINED .)
    COMMA           reduce using rule 59 (typedecl -> TYPE_UNDEFINED .)
    RPAREN          reduce using rule 59 (typedecl -> TYPE_UNDEFINED .)
    LCURLY          reduce using rule 59 (typedecl -> TYPE_UNDEFINED .)


state 64

    (8) assignment_stmt_tail -> EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 69


state 65

    (60) expression -> INTEGER . PLUS INTEGER
    (61) expression -> INTEGER . MINUS INTEGER
    (62) expression -> INTEGER . MULTIPLICATION INTEGER
    (63) expression -> INTEGER . DIVISION INTEGER
    (64) expression -> INTEGER .

    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MULTIPLICATION  shift and go to state 72
    DIVISION        shift and go to state 73
    SEMICOLON       reduce using rule 64 (expression -> INTEGER .)


state 66

    (15) function_body -> LCURLY stmts RCURLY .

    VAR             reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)
    CONST           reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)
    COMPTIME        reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)
    PUB             reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)
    FUNCTION        reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)
    $end            reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)
    RCURLY          reduce using rule 15 (function_body -> LCURLY stmts RCURLY .)


state 67

    (14) function_signature -> access_modifier FUNCTION IDENT LPAREN . params_list RPAREN typedecl
    (11) params_list -> . param
    (12) params_list -> . param COMMA params_list
    (13) params_list -> . empty
    (10) param -> . IDENT colon_type
    (65) empty -> .

    IDENT           shift and go to state 74
    RPAREN          reduce using rule 65 (empty -> .)

    params_list                    shift and go to state 75
    param                          shift and go to state 76
    empty                          shift and go to state 77

state 68

    (7) assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .

    VAR             reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)
    CONST           reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)
    COMPTIME        reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)
    PUB             reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)
    FUNCTION        reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)
    $end            reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)
    RCURLY          reduce using rule 7 (assignment_stmt -> vardecl IDENT COLON typedecl assignment_stmt_tail .)


state 69

    (8) assignment_stmt_tail -> EQUAL expression SEMICOLON .

    VAR             reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)
    CONST           reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)
    COMPTIME        reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)
    PUB             reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)
    FUNCTION        reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)
    $end            reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)
    RCURLY          reduce using rule 8 (assignment_stmt_tail -> EQUAL expression SEMICOLON .)


state 70

    (60) expression -> INTEGER PLUS . INTEGER

    INTEGER         shift and go to state 78


state 71

    (61) expression -> INTEGER MINUS . INTEGER

    INTEGER         shift and go to state 79


state 72

    (62) expression -> INTEGER MULTIPLICATION . INTEGER

    INTEGER         shift and go to state 80


state 73

    (63) expression -> INTEGER DIVISION . INTEGER

    INTEGER         shift and go to state 81


state 74

    (10) param -> IDENT . colon_type
    (16) colon_type -> . COLON typedecl
    (17) colon_type -> . empty
    (65) empty -> .

    COLON           shift and go to state 83
    COMMA           reduce using rule 65 (empty -> .)
    RPAREN          reduce using rule 65 (empty -> .)

    colon_type                     shift and go to state 82
    empty                          shift and go to state 84

state 75

    (14) function_signature -> access_modifier FUNCTION IDENT LPAREN params_list . RPAREN typedecl

    RPAREN          shift and go to state 85


state 76

    (11) params_list -> param .
    (12) params_list -> param . COMMA params_list

    RPAREN          reduce using rule 11 (params_list -> param .)
    COMMA           shift and go to state 86


state 77

    (13) params_list -> empty .

    RPAREN          reduce using rule 13 (params_list -> empty .)


state 78

    (60) expression -> INTEGER PLUS INTEGER .

    SEMICOLON       reduce using rule 60 (expression -> INTEGER PLUS INTEGER .)


state 79

    (61) expression -> INTEGER MINUS INTEGER .

    SEMICOLON       reduce using rule 61 (expression -> INTEGER MINUS INTEGER .)


state 80

    (62) expression -> INTEGER MULTIPLICATION INTEGER .

    SEMICOLON       reduce using rule 62 (expression -> INTEGER MULTIPLICATION INTEGER .)


state 81

    (63) expression -> INTEGER DIVISION INTEGER .

    SEMICOLON       reduce using rule 63 (expression -> INTEGER DIVISION INTEGER .)


state 82

    (10) param -> IDENT colon_type .

    COMMA           reduce using rule 10 (param -> IDENT colon_type .)
    RPAREN          reduce using rule 10 (param -> IDENT colon_type .)


state 83

    (16) colon_type -> COLON . typedecl
    (23) typedecl -> . TYPE_I32
    (24) typedecl -> . TYPE_I8
    (25) typedecl -> . TYPE_U8
    (26) typedecl -> . TYPE_I16
    (27) typedecl -> . TYPE_U16
    (28) typedecl -> . TYPE_U32
    (29) typedecl -> . TYPE_I64
    (30) typedecl -> . TYPE_U64
    (31) typedecl -> . TYPE_I128
    (32) typedecl -> . TYPE_U128
    (33) typedecl -> . TYPE_ISIZE
    (34) typedecl -> . TYPE_USIZE
    (35) typedecl -> . TYPE_C_SHORT
    (36) typedecl -> . TYPE_C_USHORT
    (37) typedecl -> . TYPE_C_INT
    (38) typedecl -> . TYPE_C_UINT
    (39) typedecl -> . TYPE_C_LONG
    (40) typedecl -> . TYPE_C_ULONG
    (41) typedecl -> . TYPE_C_LONGLONG
    (42) typedecl -> . TYPE_C_ULONGLONG
    (43) typedecl -> . TYPE_C_LONGDOUBLE
    (44) typedecl -> . TYPE_F16
    (45) typedecl -> . TYPE_F32
    (46) typedecl -> . TYPE_F64
    (47) typedecl -> . TYPE_F80
    (48) typedecl -> . TYPE_F128
    (49) typedecl -> . TYPE_BOOL
    (50) typedecl -> . TYPE_ANYOPAQUE
    (51) typedecl -> . TYPE_VOID
    (52) typedecl -> . TYPE_NORETURN
    (53) typedecl -> . TYPE_TYPE
    (54) typedecl -> . TYPE_ANYERROR
    (55) typedecl -> . TYPE_ANYTYPE
    (56) typedecl -> . TYPE_COMPTIME_INT
    (57) typedecl -> . TYPE_COMPTIME_FLOAT
    (58) typedecl -> . TYPE_NULL
    (59) typedecl -> . TYPE_UNDEFINED

    TYPE_I32        shift and go to state 27
    TYPE_I8         shift and go to state 28
    TYPE_U8         shift and go to state 29
    TYPE_I16        shift and go to state 30
    TYPE_U16        shift and go to state 31
    TYPE_U32        shift and go to state 32
    TYPE_I64        shift and go to state 33
    TYPE_U64        shift and go to state 34
    TYPE_I128       shift and go to state 35
    TYPE_U128       shift and go to state 36
    TYPE_ISIZE      shift and go to state 37
    TYPE_USIZE      shift and go to state 38
    TYPE_C_SHORT    shift and go to state 39
    TYPE_C_USHORT   shift and go to state 40
    TYPE_C_INT      shift and go to state 41
    TYPE_C_UINT     shift and go to state 42
    TYPE_C_LONG     shift and go to state 43
    TYPE_C_ULONG    shift and go to state 44
    TYPE_C_LONGLONG shift and go to state 45
    TYPE_C_ULONGLONG shift and go to state 46
    TYPE_C_LONGDOUBLE shift and go to state 47
    TYPE_F16        shift and go to state 48
    TYPE_F32        shift and go to state 49
    TYPE_F64        shift and go to state 50
    TYPE_F80        shift and go to state 51
    TYPE_F128       shift and go to state 52
    TYPE_BOOL       shift and go to state 53
    TYPE_ANYOPAQUE  shift and go to state 54
    TYPE_VOID       shift and go to state 55
    TYPE_NORETURN   shift and go to state 56
    TYPE_TYPE       shift and go to state 57
    TYPE_ANYERROR   shift and go to state 58
    TYPE_ANYTYPE    shift and go to state 59
    TYPE_COMPTIME_INT shift and go to state 60
    TYPE_COMPTIME_FLOAT shift and go to state 61
    TYPE_NULL       shift and go to state 62
    TYPE_UNDEFINED  shift and go to state 63

    typedecl                       shift and go to state 87

state 84

    (17) colon_type -> empty .

    COMMA           reduce using rule 17 (colon_type -> empty .)
    RPAREN          reduce using rule 17 (colon_type -> empty .)


state 85

    (14) function_signature -> access_modifier FUNCTION IDENT LPAREN params_list RPAREN . typedecl
    (23) typedecl -> . TYPE_I32
    (24) typedecl -> . TYPE_I8
    (25) typedecl -> . TYPE_U8
    (26) typedecl -> . TYPE_I16
    (27) typedecl -> . TYPE_U16
    (28) typedecl -> . TYPE_U32
    (29) typedecl -> . TYPE_I64
    (30) typedecl -> . TYPE_U64
    (31) typedecl -> . TYPE_I128
    (32) typedecl -> . TYPE_U128
    (33) typedecl -> . TYPE_ISIZE
    (34) typedecl -> . TYPE_USIZE
    (35) typedecl -> . TYPE_C_SHORT
    (36) typedecl -> . TYPE_C_USHORT
    (37) typedecl -> . TYPE_C_INT
    (38) typedecl -> . TYPE_C_UINT
    (39) typedecl -> . TYPE_C_LONG
    (40) typedecl -> . TYPE_C_ULONG
    (41) typedecl -> . TYPE_C_LONGLONG
    (42) typedecl -> . TYPE_C_ULONGLONG
    (43) typedecl -> . TYPE_C_LONGDOUBLE
    (44) typedecl -> . TYPE_F16
    (45) typedecl -> . TYPE_F32
    (46) typedecl -> . TYPE_F64
    (47) typedecl -> . TYPE_F80
    (48) typedecl -> . TYPE_F128
    (49) typedecl -> . TYPE_BOOL
    (50) typedecl -> . TYPE_ANYOPAQUE
    (51) typedecl -> . TYPE_VOID
    (52) typedecl -> . TYPE_NORETURN
    (53) typedecl -> . TYPE_TYPE
    (54) typedecl -> . TYPE_ANYERROR
    (55) typedecl -> . TYPE_ANYTYPE
    (56) typedecl -> . TYPE_COMPTIME_INT
    (57) typedecl -> . TYPE_COMPTIME_FLOAT
    (58) typedecl -> . TYPE_NULL
    (59) typedecl -> . TYPE_UNDEFINED

    TYPE_I32        shift and go to state 27
    TYPE_I8         shift and go to state 28
    TYPE_U8         shift and go to state 29
    TYPE_I16        shift and go to state 30
    TYPE_U16        shift and go to state 31
    TYPE_U32        shift and go to state 32
    TYPE_I64        shift and go to state 33
    TYPE_U64        shift and go to state 34
    TYPE_I128       shift and go to state 35
    TYPE_U128       shift and go to state 36
    TYPE_ISIZE      shift and go to state 37
    TYPE_USIZE      shift and go to state 38
    TYPE_C_SHORT    shift and go to state 39
    TYPE_C_USHORT   shift and go to state 40
    TYPE_C_INT      shift and go to state 41
    TYPE_C_UINT     shift and go to state 42
    TYPE_C_LONG     shift and go to state 43
    TYPE_C_ULONG    shift and go to state 44
    TYPE_C_LONGLONG shift and go to state 45
    TYPE_C_ULONGLONG shift and go to state 46
    TYPE_C_LONGDOUBLE shift and go to state 47
    TYPE_F16        shift and go to state 48
    TYPE_F32        shift and go to state 49
    TYPE_F64        shift and go to state 50
    TYPE_F80        shift and go to state 51
    TYPE_F128       shift and go to state 52
    TYPE_BOOL       shift and go to state 53
    TYPE_ANYOPAQUE  shift and go to state 54
    TYPE_VOID       shift and go to state 55
    TYPE_NORETURN   shift and go to state 56
    TYPE_TYPE       shift and go to state 57
    TYPE_ANYERROR   shift and go to state 58
    TYPE_ANYTYPE    shift and go to state 59
    TYPE_COMPTIME_INT shift and go to state 60
    TYPE_COMPTIME_FLOAT shift and go to state 61
    TYPE_NULL       shift and go to state 62
    TYPE_UNDEFINED  shift and go to state 63

    typedecl                       shift and go to state 88

state 86

    (12) params_list -> param COMMA . params_list
    (11) params_list -> . param
    (12) params_list -> . param COMMA params_list
    (13) params_list -> . empty
    (10) param -> . IDENT colon_type
    (65) empty -> .

    IDENT           shift and go to state 74
    RPAREN          reduce using rule 65 (empty -> .)

    param                          shift and go to state 76
    params_list                    shift and go to state 89
    empty                          shift and go to state 77

state 87

    (16) colon_type -> COLON typedecl .

    COMMA           reduce using rule 16 (colon_type -> COLON typedecl .)
    RPAREN          reduce using rule 16 (colon_type -> COLON typedecl .)


state 88

    (14) function_signature -> access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl .

    LCURLY          reduce using rule 14 (function_signature -> access_modifier FUNCTION IDENT LPAREN params_list RPAREN typedecl .)


state 89

    (12) params_list -> param COMMA params_list .

    RPAREN          reduce using rule 12 (params_list -> param COMMA params_list .)

